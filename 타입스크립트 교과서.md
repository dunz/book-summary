# 2.2 타입 추론을 적극 활용하자
`{}` 타입은 객체가 아니라 null과 undefined를 제외한 모든 타입을 의미한다
```ts
const str3: {} = 'hello'
```
---
`const` 는 더 정확한 리터럴 타입으로 추론하고 `let`은 다른값이 들어올수 있기 때문에 더 넓게 추론한다(타입넓히기 라고 부른다)

`null`가 `undefined`를 let 변수에 대입할 때는 `any`로 추론된다(주의: 미래에 들어올 값에 대한 타입을 미리 지정해주는게 좋다)

`typeof sym`은 고유한 symbol을 의미한다(unique symbol)

obj는 객체로 속성은 변경할수 있기에 `const`든 `let`이든 hello가 `string`으로 추론된다
```ts
const str = 'hello' // 'hello'
let str = 'hello'  // 'string'

const n = null  // null
let n = null  //  any

const u = undefined  // undefined
let u = undefined  //  any

cosnt sym = Symbol('a')  // typeof sym
let sym = Symbol('a')  // symbol

const obj = { hello: 'world' }  // { hello: 'string' }
let obj = { hello: 'world' }  // { hello: 'string' }
```
---
unique symbol끼리는 서로 비교 자체가 불가능하다
```ts
const sym1 = Symbol.for('a')  // unique symbol
const sym2 = Symbol.for('a')  // unique symbol
let sym3 = Symbol.for('a')
let sym4 = Symbol.for('a')

if(sym1 === sym2) {}  // 에러
if(sym1 === sym3) {}
if(sym3 === sym4) {}
```
---
obj의 속성값이 변하지 않는것이 확실하다만 `as const`로 객체 리터럴 타입으로 명시해줄수 있다
```ts
const obj = { name: 'zero' } as const  // { readonly name: 'zero' }
const arr = [1, 3, 'five'] as const  // readonly [1, 3, 'five']
```

# 2.4 배열말고 튜플도 있다
배열 각 요소에 타입을 지정해줄수 있고 그럼 인덱스로 접근시 에러를 낼수있다 

push나 pop, unshift, shift 등 튜플에 추가 제거 등은 허용하는데 이것까지 막으려면 readonly를 지정해준다

```ts
const tuple = readonly [number, boolean, string] = [1, false, 'hi']
tuple.push('no')  // 에러
```
---
튜플은 `...타입` 으로 특정 타입이 연달아 올수있음을 알릴수 있기 때문에 길이가 고정된 배열을 뜻하지는 않는다
```ts
const strNumBools: [string, number, ...boolean[]] = ['hi', 123, false, true, false]
const strNumsBool: [string, ...number[], boolean] = ['hi', 123, 4, 56, false]
const strsNumBool: [...string[], number, boolean] = ['hi', 'hello', 'wow', 123, false]
```
---
튜플에서 타입 뒤 `?`로 옵셔널 지정을 할 수 있다
```ts
let tuple: [number, boolean?, string?] = [1, false, 'hi']
tuple = [3, true]
tuple = [5]
tuple = [7, 'no']  // 'no' 에러: boolean자리에 string이 올수 없다
```

# 타입스크립트에만 있는 타입을 배우자
대표적으로 `JSON.parse`와 `fetch`의 결과는 `any`이기 때문에 타입을 명시해주는게 좋다
```ts
fetch('url').thne<{data: string}>(response => {
  return response.json()
}).then(result => {  // result: {data: string} 
})

const result: { hello: string } = JSON.parse('{"hello": "json"}')
```
---
`unknown`은 `any`와 비슷하게 모든 타입을 대입할 수 있지만 그 후 어떠한 동작도 수행할 수 없다
```ts
const a: unknown = 'hello'
const b: unknown = 'world'
a + b  // 에러
a.slice()  // 에러

try {
} catch (e) {  // e: unknown
  console.log(e.message)  // 에러: 'e' is of type 'unknown'
  console.log((e as Error).message)  // as로 타입을 주장할 수 있다
}
```
---
함수의 반환값이 없을경우 `void`가 된다
```ts
const func: () => void = () => 3  // 함수 자체를 () => void 함수 타입으로 지정할 경우 undefined가 아닌 반환값도 허용한다
const value = func()  // value: void

const func2 = (): void => 3  // 함수의 반환값을 void로 지정할 경우 undefined가 아닌 반환값을 허용하지 않는다
```
