# 2.2 타입 추론을 적극 활용하자
`{}` 타입은 객체가 아니라 null과 undefined를 제외한 모든 타입을 의미한다
```ts
const str3: {} = 'hello'
```
---
`const` 는 더 정확한 리터럴 타입으로 추론하고 `let`은 다른값이 들어올수 있기 때문에 더 넓게 추론한다(타입넓히기 라고 부른다)

`null`가 `undefined`를 let 변수에 대입할 때는 `any`로 추론된다(주의: 미래에 들어올 값에 대한 타입을 미리 지정해주는게 좋다)

`typeof sym`은 고유한 symbol을 의미한다(unique symbol)

obj는 객체로 속성은 변경할수 있기에 `const`든 `let`이든 hello가 `string`으로 추론된다
```ts
const str = 'hello' // 'hello'
let str = 'hello'  // 'string'

const n = null  // null
let n = null  //  any

const u = undefined  // undefined
let u = undefined  //  any

cosnt sym = Symbol('a')  // typeof sym
let sym = Symbol('a')  // symbol

const obj = { hello: 'world' }  // { hello: 'string' }
let obj = { hello: 'world' }  // { hello: 'string' }
```
---
unique symbol끼리는 서로 비교 자체가 불가능하다
```ts
const sym1 = Symbol.for('a')  // unique symbol
const sym2 = Symbol.for('a')  // unique symbol
let sym3 = Symbol.for('a')
let sym4 = Symbol.for('a')

if(sym1 === sym2) {}  // 에러
if(sym1 === sym3) {}
if(sym3 === sym4) {}
```
---
obj의 속성값이 변하지 않는것이 확실하다만 `as const`로 객체 리터럴 타입으로 명시해줄수 있다
```ts
const obj = { name: 'zero' } as const  // { readonly name: 'zero' }
const arr = [1, 3, 'five'] as const  // readonly [1, 3, 'five']
```



